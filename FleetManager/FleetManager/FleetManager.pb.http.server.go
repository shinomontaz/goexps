// Code generated by protoc-gen-go-http-server. DO NOT EDIT.
// source: FleetManager/FleetManager.proto

package FleetManager

import (
	"errors"
	"net/http"

	"gitlab.ozon.ru/platform/protobuf/protoc-gen-go-http-server/types"
)

type HTTPServer struct {
	handlers map[string]http.HandlerFunc
	opts     _HTTPServerOptions
}

func WithImpl(s FleetManagerServer) HTTPServerOption {
	return func(opts *_HTTPServerOptions) {
		opts.srv = s
	}
}

func WithCodec(c types.Codec) HTTPServerOption {
	return func(opts *_HTTPServerOptions) {
		opts.cdc = c
	}
}

// WithAdditionalHandler adds additional http.Handler
// it will be called instead of types.ErrMethodNotFound error
func WithAdditionalHandler(h http.Handler) HTTPServerOption {
	return func(opts *_HTTPServerOptions) {
		opts.fallback = h
	}
}

func WithMiddleware(mw func(http.Handler) http.Handler) HTTPServerOption {
	return func(opts *_HTTPServerOptions) {
		opts.mw = mw
	}
}

type _HTTPServerOptions struct {
	srv      FleetManagerServer
	cdc      types.Codec
	fallback http.Handler
	mw       func(http.Handler) http.Handler
}

var defaultHTTPServerOptions _HTTPServerOptions

type HTTPServerOption func(*_HTTPServerOptions)

func NewHTTPServer(opts ...HTTPServerOption) *HTTPServer {
	s := &HTTPServer{opts: defaultHTTPServerOptions}
	for _, opt := range opts {
		opt(&s.opts)
	}
	s.handlers = map[string]http.HandlerFunc{
		"GetZone":  s.GetZone,
		"GetZones": s.GetZones,
		"GetFleet": s.GetFleet,
	}
	return s
}

func (s *HTTPServer) Handler(name string) (http.HandlerFunc, bool) {
	h, ok := s.handlers[name]
	return h, ok
}

func (s *HTTPServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	hf := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if origin := r.Header.Get("Origin"); origin != "" {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			if r.Method == "OPTIONS" && r.Header.Get("Access-Control-Request-Method") != "" {
				w.Header().Set("Access-Control-Allow-Headers", "Content-Type,Accept")
				w.Header().Set("Access-Control-Allow-Methods", "GET,POST")
				return
			}
		}
		if s.opts.cdc == nil {
			s.opts.cdc.WriteResponse(w, nil, errors.New("codec is not defined"))
			return
		}
		r, method, _, err := s.opts.cdc.ReadRequest(r)
		if err == types.ErrMethodNotFound && s.opts.fallback != nil {
			s.opts.fallback.ServeHTTP(w, r)
			return
		}
		if err != nil {
			s.opts.cdc.WriteResponse(w, nil, err)
			return
		}
		if handler, ok := s.Handler(method); ok {
			handler(w, r)
			return
		}
		s.opts.cdc.WriteResponse(w, nil, errors.New("handler is not found for request"))
	})
	if s.opts.mw != nil {
		s.opts.mw(hf).ServeHTTP(w, r)
	} else {
		hf.ServeHTTP(w, r)
	}
}
